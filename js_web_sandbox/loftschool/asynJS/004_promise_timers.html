<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title> <!-- Node type: element -->
    </head>
    <body>
    <button id="myButton">click this shit!</button>
    <script>
        var url1 = 'https://i.pinimg.com/736x/cb/fc/27/cbfc2762b05bc04b733365dc34d350af--kitty.jpg';
        var url2 = 'https://i.pinimg.com/736x/69/f8/74/69f874d2e381e562cd921a654862d447--pet-pet-cute-kitty.jpg';
        var url3 = 'https://i.pinimg.com/736x/7a/f6/66/7af666b4ac7e96bd262ec27e5e7461a4--animal-cute-animals-adorable.jpg';

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                var i = new Image();
                document.body.appendChild(i);
                i.src = url;

                i.addEventListener('load', () => {
                    resolve();
                });
                i.addEventListener('error', () => {
                    reject();
                });
            });
        }

        var p = loadImage(url1);

        // так как метод then возвращает новый промис, мы можем, организовать взаимодействие
        // похожее на pipe - p.then().then().then()
        p.then(
            () => {
                console.log('Image 1 load -> success!!!1111oneoneone');
                return loadImage(url2);
            },
            () => {
                console.log('Image 1 load -> failed!!!fuckfuckfuck');
            }
        ).then(
            () => {
                console.log('Image 2 load -> success!!!1111oneoneone');
                return loadImage(url3);
            },
            () => {
                console.log('Image 2 load -> failed!!!fuckfuckfuck');
            }
        ).then(
            () => {
                console.log('Image 3 load -> success!!!1111oneoneone');
            },
            () => {
                console.log('Image 3 load -> failed!!!fuckfuckfuck');
            }

        );
        // если необходимо загрузить заранее неизвестное количество картинок последовательно
        // уже придумано решение - promise waterfall

    </script>
    </body>
</html>
